import {Expr, ArrayLiteralExpr, AttachEventExprStmt, BracketExpr, AssignStmt, ClassDecl, ConcatStringExpr, ConstDeclStmt, ConstructorDecl,
        DefaultPropExpr, ExpandIteratorExpr, ExpressionStmt, ForIteratorStmt, FunctionDeclExpr, ForLoopStmt, FunctionDeclStmt, FunctionInvokeExpr,
        FunctionInvokeStmt, IfStmt, LambdaExpr, LineStmt, LiteralExpr, LtEqExpr, MethodDecl, MethodInvokeExpr, MethodInvokeStmt, NewInstanceExpr, ObjectLiteralExpr,
        PropAssignExprStmt, Statement, ReturnStmt, SwitchStmt, Unit, VarDeclStmt, ImportStmt, AwaitExpr, CreateElementExpr
    } from './codedom.js';

import {HTML_ATTRS} from './html-attr.js';

import {Molecule} from './molecule-comp.js';
import * as m from './molecule-comp.js';

(this||window).MoleculeModule = m;

const MoleculeDefines = {};

export var DEBUG = false;

var nextTempId = 1;

var _scanningEle = null;

function ready(element, handler) {    
    jQuery(element).on('molecule-inited', handler);    
}

function extractPathes(document){
    const head = document.head || document.querySelector('head');
    const importContextEl = head.querySelector('meta[name=import_context]');
    const contextPath = (importContextEl && importContextEl.getAttribute('value')) || null;
    const modulesEl = head.querySelector('meta[name=node_modules]');
    const modulesPath = (modulesEl && modulesEl.getAttribute('value')) || null ;
    if(contextPath == null && modulesPath == null) return null;
    return {contextPath, modulesPath};
}

function locatePath(pathContext, path){
    if(path.startsWith('.')){       // relative
        if(pathContext == null) return path;
        if(pathContext.instPage){
            var link = document.createElement('a');
            link.href = new URL(path, pathContext.instUrl);
            return link.href;
        } else {    // if(pathContext.compPage || pageContext.instPage == null)
            var link = document.createElement('a');
            link.href = new URL(path, pathContext.compUrl);
            return link.href;
        }
    } else if(path.startsWith('/')){    // absolute
        if(pathContext == null){
            return path;
        }
        return (pathContext.instPage.contextPath || pathContext.compPage.contextPath) + path;
    } else {        // to modules
        if(pathContext == null){
            return path;
        }
        if(pathContext.instPage){
            path = pathContext.instPage.contextPath + pathContext.instPage.modulesPath + path;
            var link = document.createElement('a');
            link.href = new URL(path, pathContext.instUrl);
            return link.href;
        } else if(pathContext.compPage) {
            path = pathContext.compPage.contextPath + pathContext.compPage.modulesPath + path;
            var link = document.createElement('a');
            link.href = new URL(path, pathContext.compUrl);
            return link.href;
        } else {
            return './' + path;
        }
    }
}

/**
 * 加载指定 html 文件中的所有 molecule。
 * 
 * @param html
 *            {string} 包含有 molecule 的 html 文件的文件路径。不用包含webapp路径。
 * @returns {Boolean} 是否加载成功
 */
export async function loadHtml(res) {
    var link = document.createElement('a');
    link.href = res;
    if(_LOAD_ONCE_RESOURCE[link.href]) return;
    
    _LOAD_ONCE_RESOURCE[link.href] = 1
    
    const resp = await fetch(link.href, {credentials: 'include'});
    const text = await resp.text();
    const dom = new DOMParser().parseFromString(text, 'text/html');
    const pathes = {compPage: extractPathes(dom.documentElement), instPage: extractPathes(document)};
    pathes.compUrl = link.href;
    pathes.instUrl = document.URL;

    for(var m of Array.prototype.slice.call(dom.documentElement.querySelectorAll('molecule[src]'))){
		await loadHtml(new URL(m.getAttribute('src'), link.href));
    }
    
    await scanDefines(dom, link.href, true, pathes);	// this is a promise
    return true;
}

/**
 * 
 * @param starter 
 * @param baseUrl 
 * @param includeAllResources 是否引用所有资源。对于 loadHtml 指定为 true。此开关开启将全页面引用的 script、style 等作为生成项引入。
 */
async function scanDefines(starter, baseUrl, includeAllResources=false, pathes) {
    const unit = new Unit();
    starter = starter || document;
    
    // unit.children.push(new ImportStmt('{Molecule, Prop, EventHandlerProvider}', locatePath(pathes, 'molecule/molecule-comp.js')));
    
    const imports = [...starter.querySelectorAll('import'), 
                     ...Array.of(...starter.querySelectorAll('template')).reduce((acc, t) => [...acc, ...t.content.querySelectorAll('import')], [])];

    for(var el of imports){
        unit.children.push(new ImportStmt(el.getAttribute('tokens'), locatePath(pathes, el.getAttribute('src'))));
        el.remove();
    }

    if(includeAllResources){
        for(let res of Array.prototype.concat(...starter.querySelectorAll('script[src]'), ...starter.querySelectorAll('link[rel=stylesheet]'))){
            let srcAttr = res.tagName == 'SCRIPT' ? 'src' : 'href';
            let url = absolute(baseUrl, res.getAttribute(srcAttr))
            if(_LOAD_ONCE_RESOURCE[url]) continue;
            _LOAD_ONCE_RESOURCE[url] = 1;
            const expr = new CreateElementExpr(res.tagName, Object.assign(getAttributes(res), {[srcAttr]: url}));
            unit.children.push(new MethodInvokeStmt(expr, 'appendTo', [new Expr('document.head')]));
        }        
    }
    
    const scripts = [...starter.querySelectorAll('script'), 
                     ...Array.of(...starter.querySelectorAll('template')).reduce((acc, t) => [...acc, ...t.content.querySelectorAll('script')], [])];
    const mDefs = [...starter.querySelectorAll('[m-def]'), 
                    ...Array.of(...starter.querySelectorAll('template')).reduce((acc, t) => [...acc, ...t.content.querySelectorAll('[m-def]')], [])];

    for(var el of scripts){       // not class script of molecule, merge to unit
        if(el.hasAttribute('m-class')) continue;
        unit.children.push(new Expr(el.innerHTML));
        el.remove();
    }

    var found = false;
    for(var el of mDefs) {
        await collectDefine(el, baseUrl, unit);
        el.remove();
        found = true;
    }

    // if (found && template.content.childElementCount == 0) {
    //     template.remove();
    // }
    if(found){
        console.log(unit.toCode(0));
        let code = unit.toCode(0);
        const b = new Blob([code], {type: 'application/javascript'});
        await import(URL.createObjectURL(b));
    }
}

function getAttributes(node) {
    var i,
        attributeNodes = node.attributes,
        length = attributeNodes.length,
        attrs = {};
    for ( i = 0; i < length; i++ ) attrs[attributeNodes[i].name] = attributeNodes[i].value;
    return attrs;
}
    


const _LOAD_ONCE_RESOURCE = {};
async function collectDefine(prototypeElement, baseUrl, unit){
    var fullname = prototypeElement.getAttribute('m-def');
    prototypeElement.removeAttribute('m-def');
    //console.log('define molecule ' + fullname);

    try {
        MoleculeDefines[fullname] = prototypeElement;
        MoleculeDefines[fullname].moleculeSrc = baseUrl;
        prototypeElement.moleculeName = fullname;
        prototypeElement.extends = prototypeElement.getAttribute('m');
        prototypeElement.removeAttribute('m');
        
        await compileDefine(prototypeElement, fullname, unit);
    } catch (e) {
        console.error('load ' + fullname + ' failed, ', e);
    }
}

function absolute(base, relative) {
    if(relative.charAt(0) == '/') return relative;
    
    var stack = base.split("/"),
        parts = relative.split("/");
    stack.pop(); // remove current file name (or empty string) (omit if "base" is the current folder without trailing slash)
    for (var i=0; i<parts.length; i++) {
        if (parts[i] == ".")
            continue;
        if (parts[i] == "..")
            stack.pop();
        else
            stack.push(parts[i]);
    }
    return stack.join("/");
}

function dashToCamelCase( myStr ) {
    return myStr.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}

function camelCaseToDash( myStr ) {
    return myStr.replace( /([a-z])([A-Z])/g, '$1-$2' ).toLowerCase();
}

function getTagName(node){
    if(node instanceof Text) return 'string';
    if(node instanceof Comment) return 'comment';
    let tagName = node.tagName && node.tagName.toLowerCase();
    if(tagName == 'm' && node.hasAttribute('tag')){   // <m tag="table">
        tagName = node.getAttribute('tag').toLowerCase();
    }
    return tagName;
}

async function compileDefine(prototypeElement, fullname, unit=null){
    let classScript = prototypeElement.querySelector('script[m-class]');
    if (classScript == null) {
        classScript = prototypeElement.parentNode.querySelector("script[m-class='" + fullname + "']");
    }
    if (classScript) {
        prototypeElement.moleculeConstructor = classScript;
        classScript.remove();
    }

    const className = fullname.replace(/\./g, '$');       // as identifier, use as className, loop function name.  mui$Button eg
    if(unit == null) {
        unit = new Unit();

        const pathes = {compPage: extractPathes(document), instPage: extractPathes(document)};
        pathes.compUrl = document.URL;
        pathes.instUrl = document.URL;
        // unit.children.push(new ImportStmt('{Molecule, Prop, EventHandlerProvider}', locatePath(pathes, 'molecule/molecule-comp.js')));
    }
    const extendsClz = prototypeElement.extends;
    let c = new ClassDecl(className, extendsClz ? new Expr(`MoleculeModule.Molecule.TYPES['${extendsClz}']`) : new Expr('MoleculeModule.Molecule'), true)
    unit.children.push(c);

    let renderer = new MethodDecl('createChildren', ['$c', 'nested']);
    c.children.push(renderer);
    //renderer.children.push(new LineStmt('console.info(this.constructor.name, nested)'));
    //renderer.children.push(new LineStmt('debugger'));

    if(prototypeElement.moleculeConstructor){
        c.children.push(new Expr(prototypeElement.moleculeConstructor.innerHTML));
    }
    
    let defaultProps = {}
    for(let attr of prototypeElement.attributes){
        var value = attr.value;
        var [propName, attrName, type, isCustomProp, isExpr, isRuntime, isEcho] = parseAttributeName(prototypeElement, attr.name);
        var expr = parseAttributeValue(value, type, isExpr, false) 
        defaultProps[propName] = new DefaultPropExpr(propName, type, isCustomProp, isExpr, isRuntime, isEcho, expr);
    }
    if(!soloTextNode(prototypeElement, defaultProps, false)){
        let createChildrenExpr = new MethodInvokeExpr('super', 'createChildren', 
                    [new Expr('$c'), compileChildren(Array.from(prototypeElement.childNodes), renderer, undefined, className)]);
        renderer.children.push(new ReturnStmt(createChildrenExpr));
    } else {
        renderer.children.push(new ReturnStmt(new MethodInvokeExpr('super', 'createChildren', [])));
    }

    let defaultPropsStmt = new AssignStmt(className + '.defaultProps', new ObjectLiteralExpr(defaultProps));
    unit.children.push(defaultPropsStmt);

    unit.children.push(new LineStmt(`MoleculeModule.Molecule.extends(${JSON.stringify(fullname)}, ${className})`));

    function parseAttributeValue(value, type, isExpr, isInstancing){
        if(type == 'evt'){
            if(isExpr){
                if(!isInstancing){
                    let fun = new FunctionDeclExpr('', [], [new ReturnStmt(new Expr(value))]);
                    // new Prop(function(event, target, $c){return <<code>>});
                    return new NewInstanceExpr('MoleculeModule.EventHandlerProvider', [fun]);
                } else {
                    // this.element.click = this.wrapHandler(<<code>>)
                    return new MethodInvokeExpr('this', 'wrapHandler', [new Expr(value)]);
                }
            } else {
                if(!isInstancing){
                    // new Prop(function(){<<code>>}), in Prop.getValue(_this) bind to the instance
                    let fun = new FunctionDeclExpr('', ['event', 'target','$c'], [new LineStmt(value)]);
                    return fun;
                } else {
                    // button.click = this.wrapHandler(function(event, target, $c){<<code>>})    // `this` means molecule of renderDOM, in the <<code>> `target` means element
                    let fun = new FunctionDeclExpr('', ['event', 'target', '$c'], [new LineStmt(value)]);
                    return new MethodInvokeExpr('this', 'wrapHandler', [fun]);
                }
            }
        }
        if(isExpr){     // expr
            if(isInstancing)
                return new Expr(value);
            else
                return new FunctionDeclExpr('', ['$c'], [new ReturnStmt(new Expr(value))])
        } else {
            return new LiteralExpr(Molecule.castType(value, type), type);
        }
    }

    function soloTextNode(el, props, isInstancing){
        if(el.childNodes.length == 1 && el.firstChild instanceof Text){
            let s = el.firstChild.textContent;
            if(s.indexOf('${') != -1 && s.indexOf('}') != -1){
                // 
            } else {
                if(!isInstancing){
                    props['innerHTML'] = new DefaultPropExpr('innerHTML', 's', false, true, false, false, s);
                } else {
                    props['innerHTML'] = new LiteralExpr(s, 's');
                }
                return true;
            }
        }
    }

    function compileChildren(children, renderer, embedFunctionId={id:1}, prefix='key'){
        let array = new ArrayLiteralExpr();
        var keyId = 1;
        for(let child of children){
            let props = {};
            let tagName = getTagName(child);
            var key = null;
            if(child instanceof HTMLElement){
                for(let cattr of child.attributes){
                    let value = cattr.value;
                    let [propName, attrName, type, isCustomProp, isExpr, isRuntime, isEcho] = parseAttributeName(child, cattr.name);
                    if(isRuntime) throw ':r(untime) option can only appear within molecule define';
                    if(isEcho) throw ':e(cho) option can only appear within molecule define';
                    var expr = parseAttributeValue(value, type, isExpr, true);
                    if(propName == 'key'){
                        key = expr;
                    } else {
                        props[propName] = expr;
                    }
                }
                if(!key){
                    key = new ConcatStringExpr(prefix, '_', keyId++);
                }
                if(child  instanceof HTMLStyleElement){
                    props.innerHTML = compileSimpleText(child.innerHTML)
                    if(props.outside){
                        let d = {$:tagName, key: key, props: new ObjectLiteralExpr(props)};
                        renderer.children.splice(0, 0, new MethodInvokeStmt('this', 'createOutsideStyle', [new ObjectLiteralExpr(d)]));
                        continue;
                    }
                }
            } else if(child instanceof Text){
                // TODO 有时需要文本隔开，如两个按钮
                if((child.nextSibling || !array.isEmpty()) && child.textContent.trim() == '') continue;  // ignore empty blank
                key = new ConcatStringExpr(prefix , '_', keyId++);
                var embed = compileText(child, renderer, key);
                if(embed){
                    array.extends(embed);
                    continue;
                } else {
                    tagName = 'string';
                    props.textContent = child.textContent;
                }
            } else if(child instanceof Comment){
                tagName = 'comment';
                props.textContent = child.textContent;
            }

            if(tagName == 'if'){
                let funcName = className + '_if_' + (embedFunctionId.id ++);
                renderer.children.push(compileIfFunction(child, funcName, renderer, embedFunctionId));
                array.push(new ExpandIteratorExpr(new FunctionInvokeExpr(funcName,[])));
                continue;
            } else if (tagName == 'for'){
                let funcName = className + '_loop_' + (embedFunctionId.id ++);
                renderer.children.push(compileForLoopFunction(child, funcName, renderer, embedFunctionId));
                array.push(new ExpandIteratorExpr(new FunctionInvokeExpr(funcName,[new Expr('nested')], prefix)));
                continue;
            } else if(tagName == 'switch'){
                let funcName = className + '_switch_' + (embedFunctionId.id ++);
                renderer.children.push(compileSwitchFunction(child, funcName, renderer, embedFunctionId));
                array.push(new ExpandIteratorExpr(new FunctionInvokeExpr(funcName,[])));
                continue;
            }
            
            let d = {$:tagName, key: key, props: new ObjectLiteralExpr(props)};
            if(!soloTextNode(child, props, true) && !(child instanceof HTMLStyleElement)){
                let childrenDeep = compileChildren(Array.from(child.childNodes), renderer, embedFunctionId);
                if(!childrenDeep.isEmpty()) d.children = childrenDeep;
            }
            array.push(new ObjectLiteralExpr(d));
        }
        return array;
    }

    function compileSimpleText(text){
        if(text.indexOf('${') > -1 && text.indexOf('}') > -1){
            return new Expr('`' + text + '`')
        } else {
            return new LiteralExpr(text, 's');
        }
    }

    function compileText(textNode, renderer, baseKey){
        let text = textNode.textContent;
        let pos = text.indexOf('${');
        if(pos == -1) return;
        
        var array = new ArrayLiteralExpr();
        var end = 0;
        var keyId = 1;
        for(var start = pos;start != -1; start = text.indexOf('{{', end)){
            var notCode = text.substring(end, start);
            if(end != 0 || notCode.trim()){
                var d = {$:'string', key: baseKey.extends('_' , keyId++), props:{textContent: notCode}};
                array.push(new ObjectLiteralExpr(d));
            }
            start += 2;
            var end = text.indexOf('}', start);  // TODO 还需要跳过 js 里的 {{}}
            var code = text.substring(start, end);
            var key = baseKey.extends('_' , keyId++);
            array.push(new ExpandIteratorExpr(new MethodInvokeExpr('this', 'wrapChildren', [new Expr(code), key])));  // ...this.wrapChildren(expr, key)
            end += 1;
        }
        var remain = text.substring(end);
        if(remain.trim()){
            var d = {$:'string', key: baseKey.extends('_' , keyId++), props:{textContent: remain}};
            array.push(new ObjectLiteralExpr(d));
        }
        return array;
    }

    function compileIfFunction(ifElement, funcName, renderer, embedFunctionId){
        let branches = [];
        let cond = new Expr(ifElement.getAttribute('cond'));
        let branch = {cond: cond, then: []}
        branches.push(branch);
        for(let then = ifElement.firstChild; then != null; then = then.nextSibling){
            if(then.tagName == 'ELSE'){
                let elseEl = then;
                let cond = elseEl.getAttribute('cond')
                let elseBranch = {cond: cond ? new Expr(cond) : null, then:[]}                    
                for(let elseEl = then.firstChild; elseEl != null; elseEl = elseEl.nextSibling){
                    elseBranch.then.push(elseEl);
                }
                branches.push(elseBranch);
            } else {
                branch.then.push(then);
            }
        }
        var index = 0
        for(let branch of branches){
            index ++;
            branch.then = [new ReturnStmt(compileChildren(branch.then, renderer, embedFunctionId, funcName + '_' + index))];
        }

        let stmt = new IfStmt(branches);
        let fun = new ConstDeclStmt(funcName, new BracketExpr(new LambdaExpr(null, [stmt])));
        renderer.children.push(fun);
    }

    function compileForLoopFunction(forElement, funcName, renderer, embedFunctionId){
        /*
            <for it='' over='' [key='']></for>
            <for var='' from='' to='' step='' [key='']></for>
            <for init='' cond='' step='' key=''></for>
            <for times=''></for>
         */
        let resultDecl = new VarDeclStmt('array', new Expr('[]'));
        var forStmt = null;

        var iterator = null, container = null, keyExpr = null;
        if(forElement.hasAttribute('key')){
            keyExpr = new Expr(forElement.getAttribute('key'));
        }
        let varName = forElement.getAttribute('var');
        if(varName){
            iterator = new Expr(varName);
            container = new MethodInvokeExpr('this', 'range', [new Expr(forElement.getAttribute('from')), new Expr(forElement.getAttribute('to')), new Expr(forElement.getAttribute('step'))]);
        }
        if(!iterator){
            iterator = forElement.getAttribute('it');
            if(iterator){
                iterator = new Expr(iterator);
                container = new Expr(forElement.getAttribute('over'));
            }
        }
        let children = compileChildren(Array.from(forElement.childNodes), renderer, embedFunctionId, funcName);
        let c2 = new ConstDeclStmt('children', children);
        if(iterator){
            keyExpr = keyExpr || new MethodInvokeExpr('JSON', 'stringify', [iterator]);
            // keyExpr = keyExpr || new ConcatStringExpr(funcName, '_' , new MethodInvokeExpr('JSON', 'stringify', [iterator]));
            let cloneChildren = new MethodInvokeExpr('this', 'cloneChildren', [new Expr('children'), keyExpr]);
            let extendsChildren = new MethodInvokeStmt('Array.prototype.push', 'apply', [new Expr('array'), cloneChildren]);
            forStmt = new ForIteratorStmt(iterator, container, [c2, extendsChildren]);
        } else {
            let isTimes = forElement.hasAttribute('times');
            if(isTimes){
                keyExpr = keyExpr || new Expr('time');
            }
            let cloneChildren = new MethodInvokeExpr('this', 'cloneChildren', [new Expr('children'), keyExpr]);
            let extendsChildren = new MethodInvokeStmt('Array.prototype.push', 'apply', [new Expr('array'),  cloneChildren]);
            if(isTimes){
                forStmt = new ForLoopStmt(new Expr('let time=1'), new LtEqExpr(new Expr('time'), new Expr(forElement.getAttribute('times'))), new Expr('time++'), 
                        [c2, extendsChildren]); 
            } else {
                forStmt = new ForLoopStmt(new Expr(forElement.getAttribute('init')), new Expr(forElement.getAttribute('cond')), new Expr(forElement.getAttribute('step')), 
                        [c2, extendsChildren]);
            }
        }
        let fun = new ConstDeclStmt(funcName, new BracketExpr(new LambdaExpr(['nested', 'prefix'], [resultDecl,  forStmt, new ReturnStmt(new Expr('array'))])));
        renderer.children.push(fun);
    }

    function compileSwitchFunction(switchElement, funcName, renderer, embedFunctionId){
        let branches = [];
        let cond = new Expr(switchElement.getAttribute('cond'));
        for(let then = switchElement.firstChild; then != null; then = then.nextSibling){
            if(then.tagName == 'CASE'){
                let branchEl = then;
                let props = {};
                for(let cattr of branchEl.attributes){
                    let value = cattr.value;
                    let [propName, attrName, type, isCustomProp, isExpr, isRuntime, isEcho] = parseAttributeName(branchEl, cattr.name);
                    let expr = parseAttributeValue(value, type, isExpr, true);
                    props[propName] = expr;
                }
                let cond = props['value'];
                let branch = {cond: cond, then:[]}                    
                for(let branchDoEl = branchEl.firstChild; branchDoEl != null; branchDoEl = branchDoEl.nextSibling){
                    branch.then.push(branchDoEl);
                }
                branches.push(branch);
            }
        }
        var index = 0
        for(let branch of branches){
            index ++;
            branch.then = [new ReturnStmt(compileChildren(branch.then, renderer, embedFunctionId, funcName + '_' + index))];
        }

        let stmt = new SwitchStmt(cond, branches);
        let fun = new ConstDeclStmt(funcName, new BracketExpr(new LambdaExpr(null, [stmt])));
        renderer.children.push(fun);
    }

    // let code = unit.toCode(0);
    // console.log(code);
    // return code;
    return unit;
}

const attrReg = /(?<name>[^\/^:]+)(?<type>:([s|n|b|d|o]|evt))?(?<isExpr>:x)?(?<isRuntime>:r)?(?<isEcho>:e)?$/;
function parseAttributeName(element, attrName){ 
    /*
        attr syntax: [m-]attr[:n|s|o|b|d|x|e][/r]
        regexp: /(?<name>[^\/^:]+)(?<type>:[s|n|b|d|o|evt])?(?<isExpr>:x)?(?<isRuntime>:r)?(?<isEcho>:e)?$/
    */
    let groups = attrReg.exec(attrName).groups;
    var {name, type, isExpr, isRuntime, isEcho} = groups;
    var propName = null, isCustomProp = false;
    let tagName = getTagName(element);
    if(type == ':evt'){            
        isCustomProp = !(name in element);
        propName = name;
    } else if(name.startsWith('on') && type == null) {
        type = ':evt';
        propName = name;
    } else {
        let desc = HTML_ATTRS.ofAttr[name];            
        if(desc != null) propName = desc.prop;
        isCustomProp = propName == null || (!desc.global && desc.tags.indexOf(tagName) == -1);
        if(isCustomProp){
            propName = dashToCamelCase(name);       // prop without attr
        }
    }
    const isCustomAttr = HTML_ATTRS.isCustomAttr(name, tagName);
    attrName = isCustomAttr ? name + (type||'') : name;
    type = type ? type.substr(1) : 's';
    return [propName, attrName, type, isCustomProp, isExpr && true, isRuntime && true, isEcho && true];
}

/**
 * 以 starter 为出发元素，初始化该元素及其子元素中的所有 molecule，如果有 molecule-init=manual 的，也将强行创建。
 * 
 * @param starter
 *            {HTMLElement} html 元素
 */
async function init(starter) {
    await scanMolecules(starter, true);
}

/**
 * 以 starter 为出发元素，初始化该元素及其子元素中的所有 molecule。
 * 
 * @param starter
 *            {HTMLElement} html 元素
 * @param manual
 *            {bool} 是否初始化声明为 molecule-init=manual 的元素
 */
async function scanMolecules(starter, manual) {
    if (starter && starter.jquery) {
        starter = starter[0];
    }
    starter = starter || document.body;
    if(starter == null) return;
    _scanningEle = starter;
    if (DEBUG) console.info('molecule scan', starter);
    var stk = [starter];
    while (stk.length) {
        var ele = stk.pop();
        if (ele.hasAttribute('m')) {
            if (ele.getAttribute('molecule-init') == 'manual' && !manual) continue; // 跳过声明为手工创建的元素
            await createMolecule(ele);
        }
        if (!ele.hasAttribute('init-children-first')) {
            for (var i = ele.children.length - 1; i >= 0; i--) {
                stk.push(ele.children[i]);
            }
        }
    }

    _scanningEle = null;
    if (DEBUG) console.info('molecule scan', starter, 'over');

    async function createMolecule(target){
        if(!createMoleculeWithoutInnerClass(target)){     // 尽量不创建内部类
            const moleculeName = target.getAttribute('m');
            target.removeAttribute('m');
            target.extends = moleculeName;
            const className = 'Temp_' + (nextTempId ++);
            const unit = await compileDefine(target, className);
            const code = unit.toCode(0);

            console.log(code);
            
            const b = new Blob([code], {type: 'application/javascript'});
            const m = await import(URL.createObjectURL(b));
            const clazz = m[className];

            for(let cattr of target.attributes){
                target.removeAttribute(cattr);
            }
            target.innerHTML = '';  // remove all children;
            new clazz(target);
        }

        function createMoleculeWithoutInnerClass(target) {
            if(target.childElementCount) return false;

            let moleculeName = target.getAttribute('m');
            var clazz = Molecule.TYPES[moleculeName];
            if(clazz == null) throw new Error(`molecule class '${moleculeName}' not found`);
            let props = {};
            var key = null;
            for(let cattr of target.attributes){
                let value = cattr.value;
                let [propName, attrName, type, isCustomProp, isExpr, isRuntime, isEcho] = parseAttributeName(target, cattr.name);
                if(isExpr || type == 'evt'){
                    return false;
                }
                if(isRuntime) throw ':r(untime) option can only appear within molecule define';
                if(isEcho) throw ':e(cho) option can only appear within molecule define';
                var expr = parseAttributeValue(value, type, isExpr, true);
                if(propName == 'key'){
                    key = expr;
                } else {
                    props[propName] = expr;
                }
                if(type == 'evt'){
                    target.removeAttribute(cattr.name);
                }
            }
            delete props['m'];
            if(!key){
                key = 'key_' + (nextTempId++);
            }
            return new clazz(target, props);
        }
    
        function parseAttributeValue(value, type, isExpr){
            switch(type){
            case 's':
                return value;
            case 'n':
                return value == ''? null : value * 1;
            case 'b':
                value = value.toLowerCase();
                if(value == 'true') return true;
                if(value == 'false') return false;
                if(value == 'y' || value == 'yes') return true;
                if(value == 'n' || value == 'no') return false;
                return true;
            case 'o':
                return JSON.parse(value);
            case 'd':
                var n = Number.parseInt(value);
                if(!isNaN(n))
                    return new Date(value);
                else
                    return Date.parse(value);
            }
            return value;
        }
    }
}

// Molecule.of = async function(ele) {
//     if(ele.jquery) ele = ele[0];
//     if(ele == null) return;
//     var r = ele.moleculeInstance;
//     if(r == null && ele.hasAttribute('m')) {
//         await scanMolecules(ele);
//         return ele.moleculeInstance;
//     }
//     return r;
// }

if(jQuery) jQuery.holdReady(true);
document.addEventListener('DOMContentLoaded', async function(){
	for(var m of Array.prototype.slice.call(document.querySelectorAll('molecule[src]'))){
		if(DEBUG) console.log('load from ' + m.getAttribute('src'));
		await loadHtml(m.getAttribute('src'));
	}
    
    const pathes = {compPage: extractPathes(document), instPage: extractPathes(document)};
    pathes.compUrl = document.URL;
    pathes.instUrl = document.URL;
	await scanDefines(document, document.baseURI, false, pathes);
	await scanMolecules();
	if(jQuery) jQuery.holdReady(false);
	
	document.addEventListener('DOMNodeInserted', async function(e) {
	    var target = e.target;
	    if (target.tagName) { // 可能嵌套于未声明为 molecule的元素中，<div><div m=...></div></div>, 仅能收到外层 div 的事件
	        if (_scanningEle && jQuery.contains(_scanningEle, target)) return; // 正在扫描父元素，早晚会扫到它
	        if (DEBUG) console.info('DOMNodeInserted ', e.target);
	        await scanMolecules(target);
	    }
	});
	
	
	document.addEventListener('DOMNodeRemoved', async function(e) {
	    var target = e.target;
	    if (target.tagName) { // 可能嵌套于未声明为 molecule的元素中，<div><div m=...></div></div>, 仅能收到外层 div 的事件
	        if (target.moleculeInstance) {
	            target.moleculeInstance && target.moleculeInstance.onDOMNodeRemoved();
	        }
	        Array.prototype.forEach.call(target.querySelectorAll('[m-inst]'), ele => {
	        	ele.moleculeInstance && ele.moleculeInstance.onDOMNodeRemoved();
	        });
	    }
    });
    
    // $(function observeThemeChange(){
    //     var config = { attributes: true, childList: true, subtree: true, attributeOldValue : true };

    //     var callback = function(mutationsList) {
    //         for(var mutation of mutationsList) {
    //             if (mutation.type == 'attributes') {
    //                 if(mutation.target.moleculeInstance){
    //                     const inst = mutation.target.moleculeInstance;
    //                     // if(inst.handleAttributeChange) 
    //                     inst.handleAttributeChange(mutation.attributeName, mutation);
    //                 }                    
    //             }
    //         }
    //     };

    //     var observer = new MutationObserver(callback);
    //     observer.observe(document.body, config);
    //     // observer.disconnect();
    // });
});
